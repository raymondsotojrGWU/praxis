# client_i9.py
import requests
import time
import json
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import tensorflow as tf
from tensorflow.keras import layers, models

# Configuration for the i9 client
CLIENT_ID = "i9"
SERVER_URL = "http://<SERVER_IP>:5000"  # Replace <SERVER_IP> with your server's IP address
TRAIN_CSV = "train_i9.csv"  # Your training CSV for i9 (75% stratified split)
TEST_CSV = "hfmltc_i9.csv"  # Provided test CSV for i9
LOCAL_EPOCHS = 5
BATCH_SIZE = 32
FED_ROUNDS = 10

# Prepare matplotlib for interactive plotting
plt.ion()
fig, ax = plt.subplots(1, 2, figsize=(12, 5))
loss_history = []
acc_history = []

def create_model():
    model = models.Sequential([
        layers.Input(shape=(55,)),
        layers.Dense(64, activation='relu'),
        layers.Dense(32, activation='relu'),
        layers.Dense(1, activation='sigmoid')
    ])
    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return model

def load_data(csv_file):
    df = pd.read_csv(csv_file)
    # Assume features are all columns except 'label'
    X = df.drop(columns=['label']).values.astype('float32')
    y = df['label'].astype('int').values
    return X, y

def plot_metrics(round_num, loss, acc):
    loss_history.append(loss)
    acc_history.append(acc)
    ax[0].clear()
    ax[0].plot(range(1, len(loss_history) + 1), loss_history, marker='o')
    ax[0].set_title("Training Loss per Round")
    ax[0].set_xlabel("Round")
    ax[0].set_ylabel("Loss")
    
    ax[1].clear()
    ax[1].plot(range(1, len(acc_history) + 1), acc_history, marker='o')
    ax[1].set_title("Training Accuracy per Round")
    ax[1].set_xlabel("Round")
    ax[1].set_ylabel("Accuracy")
    
    plt.suptitle(f"Client {CLIENT_ID} - Round {round_num}")
    plt.pause(0.1)

def get_global_weights():
    while True:
        try:
            response = requests.get(f"{SERVER_URL}/global_model")
            data = response.json()
            if 'global_weights' in data:
                return data['global_weights'], data['round']
            else:
                print("Global model not initialized yet. Waiting...")
                time.sleep(2)
        except Exception as e:
            print("Error connecting to server:", e)
            time.sleep(2)

def submit_update(round_num, weights, num_samples):
    payload = {
        "client_id": CLIENT_ID,
        "round": round_num,
        "weights": weights,
        "num_samples": num_samples
    }
    response = requests.post(f"{SERVER_URL}/submit_update", json=payload)
    return response.json()

def model_to_list(model):
    # Convert model weights (numpy arrays) to lists for JSON serialization
    return [w.tolist() for w in model.get_weights()]

def list_to_weights(weights_list):
    # Convert list back to numpy arrays
    return [np.array(w) for w in weights_list]

def main():
    # Load training data
    X_train, y_train = load_data(TRAIN_CSV)
    print(f"Client {CLIENT_ID}: Loaded training data with {X_train.shape[0]} samples.")
    
    # Load test data
    X_test, y_test = load_data(TEST_CSV)
    
    # Create local model
    model = create_model()
    
    # Initialize local model with global weights from server
    global_weights, current_round = get_global_weights()
    print(f"Client {CLIENT_ID}: Starting at round {current_round}.")
    model.set_weights(list_to_weights(global_weights))
    
    for round_num in range(current_round, FED_ROUNDS):
        print(f"Client {CLIENT_ID}: Starting round {round_num}.")
        
        # Local training
        history = model.fit(X_train, y_train, epochs=LOCAL_EPOCHS, batch_size=BATCH_SIZE, verbose=0)
        train_loss = history.history['loss'][-1]
        train_acc = history.history['accuracy'][-1]
        print(f"Client {CLIENT_ID}: Round {round_num} - Loss: {train_loss:.4f}, Accuracy: {train_acc:.4f}")
        
        # Plot the metrics in real time
        plot_metrics(round_num, train_loss, train_acc)
        
        # Submit update to server
        weights_list = model_to_list(model)
        update_response = submit_update(round_num, weights_list, int(X_train.shape[0]))
        print(f"Client {CLIENT_ID}: Server response: {update_response}")
        
        # Wait for server to update global model (poll until round number increases)
        new_global, new_round = get_global_weights()
        while new_round == round_num:
            time.sleep(1)
            new_global, new_round = get_global_weights()
        
        # Update local model with new global weights
        model.set_weights(list_to_weights(new_global))
    
    # After training, evaluate on test data and display confusion matrix.
    test_loss, test_acc = model.evaluate(X_test, y_test, verbose=0)
    print(f"Client {CLIENT_ID}: Final test loss: {test_loss:.4f}, test accuracy: {test_acc:.4f}")
    y_pred = (model.predict(X_test) > 0.5).astype(int)
    cm = confusion_matrix(y_test, y_pred)
    disp = ConfusionMatrixDisplay(confusion_matrix=cm)
    disp.plot(ax=plt.gca())
    plt.title(f"Client {CLIENT_ID} - Confusion Matrix")
    plt.show(block=True)

if __name__ == '__main__':
    main()
